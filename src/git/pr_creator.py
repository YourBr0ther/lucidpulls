"""Pull request creation functionality."""

import logging
import time
from dataclasses import dataclass
from typing import Optional

from github import Github, GithubException

from src.utils import retry

logger = logging.getLogger("lucidpulls.git.pr_creator")


@dataclass
class PRResult:
    """Result of a pull request creation."""

    success: bool
    pr_number: Optional[int] = None
    pr_url: Optional[str] = None
    error: Optional[str] = None


class PRCreator:
    """Creates pull requests on GitHub."""

    def __init__(self, github_token: str, rate_limit_delay: float = 0.5):
        """Initialize PR creator.

        Args:
            github_token: GitHub Personal Access Token.
            rate_limit_delay: Minimum delay between API calls in seconds.
        """
        self.github = Github(github_token)
        self._last_call = 0.0
        self._rate_limit_delay = rate_limit_delay

    def _rate_limit(self) -> None:
        """Ensure minimum delay between API calls."""
        elapsed = time.time() - self._last_call
        if elapsed < self._rate_limit_delay:
            time.sleep(self._rate_limit_delay - elapsed)
        self._last_call = time.time()

    def has_open_lucidpulls_pr(self, repo_full_name: str) -> bool:
        """Check if there's already an open PR from LucidPulls.

        Args:
            repo_full_name: Full repository name (owner/repo).

        Returns:
            True if an open LucidPulls PR exists.
        """
        self._rate_limit()
        try:
            repo = self.github.get_repo(repo_full_name)
            open_prs = repo.get_pulls(state="open")
            for pr in open_prs:
                if pr.head.ref.startswith("lucidpulls/"):
                    logger.info(f"Found existing LucidPulls PR: #{pr.number}")
                    return True
            return False
        except GithubException as e:
            logger.warning(f"Could not check for existing PRs: {e}")
            return False  # Proceed anyway
        except Exception as e:
            logger.warning(f"Unexpected error checking for existing PRs: {e}")
            return False

    def create_pr(
        self,
        repo_full_name: str,
        branch_name: str,
        base_branch: str,
        title: str,
        body: str,
        related_issue: Optional[int] = None,
    ) -> PRResult:
        """Create a pull request.

        Args:
            repo_full_name: Full repository name (owner/repo).
            branch_name: Branch with changes.
            base_branch: Target branch (usually main/master).
            title: PR title.
            body: PR description.
            related_issue: Optional issue number to link.

        Returns:
            PRResult with success status and PR details.
        """
        self._rate_limit()

        # Add issue reference to body if provided
        if related_issue:
            body = f"{body}\n\nCloses #{related_issue}"

        # Add LucidPulls signature
        body = f"{body}\n\n---\n\U0001F916 This PR was automatically generated by [LucidPulls](https://github.com/YourBr0ther/lucidpulls)"

        try:
            return self._create_pr_with_retry(
                repo_full_name, branch_name, base_branch, title, body
            )
        except GithubException as e:
            error_msg = str(e.data.get("message", str(e))) if hasattr(e, "data") else str(e)
            logger.error(f"Failed to create PR after retries: {error_msg}")
            return PRResult(success=False, error=error_msg)
        except Exception as e:
            logger.error(f"Unexpected error creating PR: {e}")
            return PRResult(success=False, error=str(e))

    @retry(max_attempts=3, delay=2.0, backoff=2.0, exceptions=(GithubException,))
    def _create_pr_with_retry(
        self,
        repo_full_name: str,
        branch_name: str,
        base_branch: str,
        title: str,
        body: str,
    ) -> PRResult:
        """Internal PR creation method with retry logic."""
        repo = self.github.get_repo(repo_full_name)

        pr = repo.create_pull(
            title=title,
            body=body,
            head=branch_name,
            base=base_branch,
        )

        logger.info(f"Created PR #{pr.number}: {title}")

        return PRResult(
            success=True,
            pr_number=pr.number,
            pr_url=pr.html_url,
        )

    def get_open_issues(
        self,
        repo_full_name: str,
        labels: Optional[list[str]] = None,
        limit: int = 20,
    ) -> list[dict]:
        """Get open issues from a repository.

        Args:
            repo_full_name: Full repository name (owner/repo).
            labels: Optional list of labels to filter by.
            limit: Maximum number of issues to return.

        Returns:
            List of issue dictionaries.
        """
        self._rate_limit()
        try:
            repo = self.github.get_repo(repo_full_name)

            # Get issues with optional label filter
            if labels:
                issues = repo.get_issues(state="open", labels=labels)
            else:
                # Get bugs and enhancements by default
                bug_issues = list(repo.get_issues(state="open", labels=["bug"])[:limit])
                enhancement_issues = list(
                    repo.get_issues(state="open", labels=["enhancement"])[:limit]
                )
                all_issues = bug_issues + enhancement_issues
                # Dedupe and limit
                seen = set()
                issues = []
                for issue in all_issues:
                    if issue.number not in seen:
                        seen.add(issue.number)
                        issues.append(issue)
                    if len(issues) >= limit:
                        break
                return [self._issue_to_dict(i) for i in issues]

            return [self._issue_to_dict(i) for i in list(issues)[:limit]]
        except GithubException as e:
            logger.error(f"Failed to get issues for {repo_full_name}: {e}")
            return []
        except Exception as e:
            logger.error(f"Unexpected error getting issues: {e}")
            return []

    def _issue_to_dict(self, issue) -> dict:
        """Convert GitHub issue to dictionary.

        Args:
            issue: GitHub issue object.

        Returns:
            Dictionary with issue details.
        """
        return {
            "number": issue.number,
            "title": issue.title,
            "body": issue.body or "",
            "labels": [l.name for l in issue.labels],
            "url": issue.html_url,
            "created_at": issue.created_at.isoformat() if issue.created_at else None,
        }

    def add_comment(self, repo_full_name: str, pr_number: int, comment: str) -> bool:
        """Add a comment to a pull request.

        Args:
            repo_full_name: Full repository name (owner/repo).
            pr_number: PR number.
            comment: Comment text.

        Returns:
            True if successful.
        """
        self._rate_limit()
        try:
            repo = self.github.get_repo(repo_full_name)
            pr = repo.get_pull(pr_number)
            pr.create_issue_comment(comment)
            logger.debug(f"Added comment to PR #{pr_number}")
            return True
        except GithubException as e:
            logger.error(f"Failed to add comment to PR #{pr_number}: {e}")
            return False

    def close(self) -> None:
        """Close GitHub client connection."""
        if hasattr(self, "github"):
            self.github.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
