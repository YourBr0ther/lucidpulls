"""Pull request creation functionality."""

import logging
from dataclasses import dataclass
from typing import Optional

from github import Github, GithubException, RateLimitExceededException

from src.git.rate_limiter import GitHubRateLimiter
from src.models import GithubIssue
from src.utils import retry

logger = logging.getLogger("lucidpulls.git.pr_creator")

LUCIDPULLS_LABEL = "lucidpulls"


@dataclass
class PRResult:
    """Result of a pull request creation."""

    success: bool
    pr_number: Optional[int] = None
    pr_url: Optional[str] = None
    error: Optional[str] = None


class PRCreator:
    """Creates pull requests on GitHub."""

    def __init__(self, github: Github, rate_limiter: GitHubRateLimiter):
        """Initialize PR creator.

        Args:
            github: Shared Github client instance.
            rate_limiter: Shared rate limiter instance.
        """
        self.github = github
        self._rate_limiter = rate_limiter

    def _ensure_label_exists(self, repo_full_name: str) -> None:
        """Ensure the lucidpulls label exists on the repo, creating it if needed."""
        try:
            repo = self.github.get_repo(repo_full_name)
            try:
                repo.get_label(LUCIDPULLS_LABEL)
            except GithubException:
                repo.create_label(
                    name=LUCIDPULLS_LABEL,
                    color="7B68EE",
                    description="Automated PR by LucidPulls",
                )
                logger.debug(f"Created '{LUCIDPULLS_LABEL}' label on {repo_full_name}")
        except Exception as e:
            logger.debug(f"Could not ensure label exists: {e}")

    def has_open_lucidpulls_pr(self, repo_full_name: str) -> bool:
        """Check if there's already an open PR from LucidPulls.

        Uses label filtering to avoid iterating all open PRs.

        Args:
            repo_full_name: Full repository name (owner/repo).

        Returns:
            True if an open LucidPulls PR exists.
        """
        self._rate_limiter.throttle()
        try:
            repo = self.github.get_repo(repo_full_name)

            # Try label-based search first (efficient)
            try:
                labeled_issues = repo.get_issues(
                    state="open", labels=[LUCIDPULLS_LABEL]
                )
                for issue in labeled_issues:
                    if issue.pull_request is not None:
                        logger.info(f"Found existing LucidPulls PR: #{issue.number}")
                        return True
            except GithubException:
                pass

            # Fallback: check branch prefix for PRs created before labeling
            open_prs = repo.get_pulls(state="open")
            for pr in open_prs:
                if pr.head.ref.startswith("lucidpulls/"):
                    logger.info(f"Found existing LucidPulls PR: #{pr.number}")
                    return True

            return False
        except GithubException as e:
            logger.warning(f"Could not check for existing PRs: {e}")
            return False  # Proceed anyway
        except Exception as e:
            logger.warning(f"Unexpected error checking for existing PRs: {e}")
            return False

    def create_pr(
        self,
        repo_full_name: str,
        branch_name: str,
        base_branch: str,
        title: str,
        body: str,
        related_issue: Optional[int] = None,
    ) -> PRResult:
        """Create a pull request.

        Args:
            repo_full_name: Full repository name (owner/repo).
            branch_name: Branch with changes.
            base_branch: Target branch (usually main/master).
            title: PR title.
            body: PR description.
            related_issue: Optional issue number to link.

        Returns:
            PRResult with success status and PR details.
        """
        self._rate_limiter.throttle()

        # Add issue reference to body if provided
        if related_issue:
            body = f"{body}\n\nCloses #{related_issue}"

        # Add LucidPulls signature
        body = f"{body}\n\n---\n\U0001F916 This PR was automatically generated by [LucidPulls](https://github.com/YourBr0ther/lucidpulls)"

        try:
            return self._create_pr_with_retry(
                repo_full_name, branch_name, base_branch, title, body
            )
        except GithubException as e:
            error_msg = str(e)
            if hasattr(e, "data") and isinstance(e.data, dict):
                error_msg = str(e.data.get("message", error_msg))
            logger.error(f"Failed to create PR after retries: {error_msg}")
            return PRResult(success=False, error=error_msg)
        except Exception as e:
            logger.error(f"Unexpected error creating PR: {e}")
            return PRResult(success=False, error=str(e))

    @retry(max_attempts=3, delay=2.0, backoff=2.0, exceptions=(GithubException,))
    def _create_pr_with_retry(
        self,
        repo_full_name: str,
        branch_name: str,
        base_branch: str,
        title: str,
        body: str,
    ) -> PRResult:
        """Internal PR creation method with retry logic."""
        try:
            repo = self.github.get_repo(repo_full_name)

            pr = repo.create_pull(
                title=title,
                body=body,
                head=branch_name,
                base=base_branch,
            )

            # Add lucidpulls label for efficient future lookups
            try:
                self._ensure_label_exists(repo_full_name)
                pr.add_to_labels(LUCIDPULLS_LABEL)
            except Exception as e:
                logger.debug(f"Could not add label to PR: {e}")

            logger.info(f"Created PR #{pr.number}: {title}")

            return PRResult(
                success=True,
                pr_number=pr.number,
                pr_url=pr.html_url,
            )
        except RateLimitExceededException:
            # Wait for rate limit reset before retrying
            self._rate_limiter._check_quota()
            raise

    def get_open_issues(
        self,
        repo_full_name: str,
        labels: Optional[list[str]] = None,
        limit: int = 20,
    ) -> list[GithubIssue]:
        """Get open issues from a repository.

        Args:
            repo_full_name: Full repository name (owner/repo).
            labels: Optional list of labels to filter by.
            limit: Maximum number of issues to return.

        Returns:
            List of GithubIssue typed dicts.
        """
        self._rate_limiter.throttle()
        try:
            repo = self.github.get_repo(repo_full_name)

            # Get issues with optional label filter
            if labels:
                issues = list(repo.get_issues(state="open", labels=labels)[:limit])
                return [self._issue_to_dict(i) for i in issues]

            # Get bugs and enhancements by default
            bug_issues: list = []
            enhancement_issues: list = []
            try:
                bug_issues = list(repo.get_issues(state="open", labels=["bug"])[:limit])
            except (GithubException, IndexError):
                pass
            try:
                enhancement_issues = list(
                    repo.get_issues(state="open", labels=["enhancement"])[:limit]
                )
            except (GithubException, IndexError):
                pass

            all_issues = bug_issues + enhancement_issues
            # Dedupe and limit
            seen: set[int] = set()
            issues = []
            for issue in all_issues:
                if issue.number not in seen:
                    seen.add(issue.number)
                    issues.append(issue)
                if len(issues) >= limit:
                    break
            return [self._issue_to_dict(i) for i in issues]
        except GithubException as e:
            logger.error(f"Failed to get issues for {repo_full_name}: {e}")
            return []
        except Exception as e:
            logger.error(f"Unexpected error getting issues: {e}")
            return []

    def _issue_to_dict(self, issue: object) -> GithubIssue:
        """Convert GitHub issue to GithubIssue TypedDict.

        Args:
            issue: GitHub issue object.

        Returns:
            GithubIssue typed dict.
        """
        return GithubIssue(
            number=issue.number,  # type: ignore[attr-defined]
            title=issue.title,  # type: ignore[attr-defined]
            body=issue.body or "",  # type: ignore[attr-defined]
            labels=[l.name for l in issue.labels],  # type: ignore[attr-defined]
            url=issue.html_url,  # type: ignore[attr-defined]
            created_at=issue.created_at.isoformat() if issue.created_at else None,  # type: ignore[attr-defined]
        )

    def add_comment(self, repo: str, pr_number: int, body: str) -> bool:
        """Add a comment to a pull request.

        Args:
            repo: Full repository name (owner/repo).
            pr_number: PR number to comment on.
            body: Comment body text.

        Returns:
            True if comment was added successfully.
        """
        self._rate_limiter.throttle()
        try:
            gh_repo = self.github.get_repo(repo)
            pr = gh_repo.get_pull(pr_number)
            pr.create_issue_comment(body)
            logger.info(f"Added comment to PR #{pr_number} in {repo}")
            return True
        except GithubException as e:
            logger.error(f"Failed to add comment to PR #{pr_number}: {e}")
            return False
        except Exception as e:
            logger.error(f"Unexpected error adding comment: {e}")
            return False

    def close(self) -> None:
        """Close GitHub client connection."""
        pass  # Github client is shared, closed by owner

    def __enter__(self) -> "PRCreator":
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        self.close()
